# TLDR

Understanding long and difficult academic papers is **hard because readers often lose context while reading**. We provide **active interaction** and **visual aids** to help maintain the reading context. The active interaction part helps users **continuously check on their understanding** of the paper which helps maintain reading context.


#### /frontend
**main javascript file: frontend/app.js**  
All the data is stored in app.js due to absence of necessity for backend.
The structure of the data is as follows:

      sectionHeading: `Introduction`,
      sectionContent: [
        `paragraph1`,
        `paragraph2`,
        `paragraph3`,
        `paragraph4`,
        `paragraph5`,
        `paragraph6`,
      ],
      summary: {
        model1: {
          short: `summaryShort`,
          medium: `summaryMedium`,
          long: `summaryLong`,
        },
        model2: {
          short: `summaryShort`,
          medium: `summaryMedium`,
          long: `summaryLong`,
        },
      },
    },
All sections consist of headers and content (which consists of paragraphs).  
For each section there is a summary text generated by two models.  
The two AI models each provide short, medium and long versions of the summary.

**Load contents**  

```
data.sections.forEach((s, i) => {
    const sectionWrapper = document.createElement("div");
    sectionWrapper.setAttribute("class", "section-wrapper");
    const sectionHeading = document.createElement("h2");
    sectionHeading.innerText = s.sectionHeading;
    sectionWrapper.append(sectionHeading);
    s.sectionContent.forEach((p, j) => {
      const paragraphWrapper = document.createElement("div");
      const paragraphText = document.createElement("p");
      if (i in visualMaps) {
        for (var k in visualMaps[i]) {
          if ((j+1) in visualMaps[i][k]) {
            const figure = document.createElement("img");
            const figureDesc = document.createElement("p");
            figure.setAttribute("src", visualMaps[i][k][j+1].src);
            figureDesc.setAttribute("id", `s${i}_p${j+1}_f${visualMaps[i][k][j+1].id}`);
            figureDesc.setAttribute("class", "visual-desc");
            figureDesc.innerText = visualMaps[i][k][j+1].desc;
            paragraphWrapper.append(figure);
            paragraphWrapper.append(figureDesc);
          }
        }
      }
      paragraphWrapper.setAttribute("id", `s${i}_p${j+1}`);
      paragraphWrapper.setAttribute("class", "paragraph-wrapper");
      paragraphText.innerText = p;
      paragraphWrapper.append(paragraphText);
      sectionWrapper.append(paragraphWrapper);
    });
    paperContent.append(sectionWrapper);
  });
}
```  

**Update user's context**

```
function updateContext() {  
  const paragraphs = document.getElementsByClassName("paragraph-wrapper")
  const pointer = document.getElementById("pointer");
  var ptrLoc = pointer.getBoundingClientRect().top - pointer.getBoundingClientRect().height/2;
  for (var i = 0; i < paragraphs.length; i++) {
    if (paragraphs[i].getBoundingClientRect().top < ptrLoc && 
        paragraphs[i].getBoundingClientRect().bottom > ptrLoc) {
          const ptrTxt = document.getElementById("pointer-context");
          let id = paragraphs[i].id.split('_');
          let sid = id[0].replace('s', '');
          let pid =  id[1].replace('p', '');
          ptrTxt.innerText = `Sect: ${sid} Para: ${pid}`;
          context.sid = parseInt(sid);
          context.pid = parseInt(pid);
    }
  }
}
```


#### /backend/python
**ext_summarize.py**
```
Extractive summarization using target pretrained model with defined output length.

This module gets target content, model, and expected length of the result from users,
and return(print) corresponding summarization result.

Example:
    $ ext_summarize.py [-h] [-m MODEL] [-l LENGTH] body

Attributes:
    available_models: List of the available pretrained models
        scibert: https://github.com/allenai/scibert
    available_models_src: Map between available pretrained model name and its source.
    length: Map between avaliable input length format and actual ratio value to convert.
    _params: Defined paraemters for summarization.
        {
            'body' (str): Target content to summarize
            'model' (str): Target model name to build language model (default: scibert)
            'length' (float): The ratio of sentences in final summary (default: 0.4)
        } 
```


**abst_summarize.py**
```
Abstractive summarization using target pretrained model with defined output length.

This module gets target content, model, and expected length of the result from users,
and return(print) generated summarization result.

Example:
    $ abst_summarize.py [-h] [-m MODEL] [-l LENGTH] body

Attributes:
    available_models: List of the available pretrained models
        distilbart: https://huggingface.co/sshleifer/distilbart-cnn-12-6
    available_models_src: Map between available pretrained model name and its source.
    length: Map between avaliable input length format and actual ratio value to convert.
    _params: Defined paraemters for summarization.
        {
            'body' (str): Target content to summarize
            'model' (str): Target model name to build language model (default: distilbart)
            'length' (float): The ratio of sentences in final summary (default: 0.4)
        } 
```

*Both of summarization works like belows:*
```
In main() function
1) Get model and tokenizer from user input
2) Return summarization of the body according to user requested length
    model, tokenizer = get_model(...)
    summarizer = Summarizer(model, tokenizer)
    result = summarizer(body, length)
```

**get_synonyms.py**
```
Get synonyms from the target word.

This module gets target word to find synonyms, and returns corresponding synonyms.

Example:
    $ get_synonyms.py [-h] [-n NUMBER] target
```
